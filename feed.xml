<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://blog.yangxiaochen.com</link>
    <atom:link href="http://blog.yangxiaochen.com/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>星期二, 5 九月 2017 00:48:39 +0800</pubDate>
    <lastBuildDate>星期二, 5 九月 2017 00:48:39 +0800</lastBuildDate>

    <item>
      <title>gradle简明教程</title>
      <link>http://blog.yangxiaochen.com/blog/java/gradle简明教程.html</link>
      <pubDate>星期一, 24 七月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/gradle简明教程.html</guid>
      	<description>
	&lt;!-- # gradle简明教程 --&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文没有 gradle 与 maven 对比，也没有深入 gradle 实现。只有 gradle 从 0 开始使用的说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;li&gt;新建一个 gradle 项目&lt;/li&gt;
&lt;li&gt;引入一个 gradle 项目&lt;/li&gt;
&lt;li&gt;常见问题&lt;/li&gt;
&lt;li&gt;交流&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;gradle 是一个构建工具。负责管理项目依赖，组织项目结构，完成项目构建的工作。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;从 官网 下载，解压即可，并将 bin/gradle 命令加入到 path 中。&lt;/p&gt;
&lt;h2&gt;新建一个 gradle 项目&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新建一个文件夹作为项目文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir project-example
cd project-example
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 gradle 初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后目录下会生成这些文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;build.gradle     // 构建脚本文件，主要的构建配置都在这里写
gradle           // 存放gradle wrapper 执行配置和工具的文件夹，
gradlew          // gradle wrapper 执行脚本文件，用来在没有安装 gradle 的情况下执行 gradle 命令。当然，第一次执行时会下载 gradle。
gradlew.bat      // gradle wrapper 执行脚本文件的 windows 版
settings.gradle  // 项目配置，指明根项目名字和引入的 module
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 build.gradle 文件，结果像下面这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
声明插件，声明插件的方式有两种，下面这种是 2.* 版本之后的新的定义方式。可以声明两种插件：
1. 官方内置插件，如 java，idea。
2. 在 gradle 插件中心注册过的插件，如第三个就是，这种要还要声明版本。
声明插件的目的是因为插件会提供很多 task，而每一个 task 就是一段构建脚本，可以执行不同的任务。比如 compileJava，test 等。
*/
plugins {
    id &apos;java&apos;
    id &apos;idea&apos;
    id &amp;quot;com.yangxiaochen.scaffold&amp;quot; version &amp;quot;1.0.2&amp;quot;
}

/*
声明 group 和 版本，而 project 的名字在 settings.gradle 文件中，而子 module ，或者又称为 sub projects 的名字通常和文件夹名字一样。
*/
group &apos;com.yangxiaochen.gradle&apos;
version &apos;1.0.0-SNAPSHOT&apos;

/*
声明依赖仓库，这里使用的是 jcenter，也可以使用其他的如 mavenCentral 等。也可以声明多个，会按顺序查找。
*/
repositories {
    jcenter()
}

/*
声明依赖
*/
dependencies {
    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;
    testCompile &apos;junit:junit:4.12&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑 settings.gradle 文件如下，声明了project name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rootProject.name = &apos;project-example&apos;
// include &apos;sub-project&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入到 Idea IDE 中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle idea
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目录下新生成了三个文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;project-example.iml
project-example.ipr
project-example.iws
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来只要用 Idea IDE 来 open project-example.ipr 文件，就可以引入 project 了， 之后每当&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;依赖更改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录结构更改&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只要执行 &lt;code&gt;gradle cleanIdea idea&lt;/code&gt; 就可以刷新这三个文件，Idea IDE 就会重新加载识别项目了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的经验是不要使用 Idea IDE 来直接用 build.gradle 来打开文件，因为 Idea IDE 在解析 build.gradle 文件时有其他操作，而且 Idea IDE 与 gradle 版本有时会不太兼容，导致项目解析错误；而使用 gradle 来生成 Idea IDE 工程文件的方式就不会有问题，而且速度更快，更容易debug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入之后，还需要生成 src 文件夹和 sub project&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gradle createSrc idea
gradle createModule --name foo idea
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;createSrc&lt;/code&gt; 和&lt;code&gt;createModule&lt;/code&gt;都是插件 &lt;code&gt;com.yangxiaochen.scaffold&lt;/code&gt;里的 task，而 &lt;code&gt;idea&lt;/code&gt;和&lt;code&gt;cleanIdea&lt;/code&gt; 是插件 &lt;code&gt;idea&lt;/code&gt;提供的 task&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;引入一个 gradle 项目&lt;/h2&gt;
&lt;p&gt;跟上一节创建一个 gradle 项目类似，引入&lt;code&gt;idea&lt;/code&gt;插件，然后生成 Idea IDE 的工程文件，再 open 即可&lt;/p&gt;
&lt;h2&gt;常见问题&lt;/h2&gt;
&lt;h3&gt;插件选择&lt;/h3&gt;
&lt;p&gt;内置插件都在官方文档中有说明，除了内置插件外, 可以 &lt;a href=&quot;https://plugins.gradle.org/&quot;&gt;Search Gradle plugins&lt;/a&gt;，gradle 插件的官方仓库。&lt;/p&gt;
&lt;h3&gt;build速度慢&lt;/h3&gt;
&lt;p&gt;速度慢一般来说是依赖更新慢，因为众所周知的原因，国内使用国外的仓库速度并不乐观，所以可以替换&lt;code&gt;repositories&lt;/code&gt;, 使用阿里云的仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;repositories {
  maven {
  	url &amp;quot;http://maven.aliyun.com/nexus/content/groups/public&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再者, 有的同学使用私服, 可能是公司搭建的. 这个有时候会有不稳定, 且有时需要认证的情况. 看稍后的章节.&lt;/p&gt;
&lt;h3&gt;如何debug&lt;/h3&gt;
&lt;p&gt;gradle 运行中的提示并不算很友好, 尤其在链接仓库和下载jar包时, 在连接有问题的时候, 经常没有提示(新版本的可能好一些.)&lt;/p&gt;
&lt;p&gt;经常使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle idea -i
gradle idea -id

还可以加入 --no-daemon 参数来避免daemon启动产生的日志干扰
gradle idea -id --no-daemon
一般来说就能定位到构建问题.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来获取更多的信息. 比较常见的卡住是因为&lt;code&gt;仓库链接不上&lt;/code&gt;, &lt;code&gt;jar包下载链接不上, 又不返回 response (私有仓库偶尔有问题)&lt;/code&gt;, &lt;code&gt;资源下载缓慢&lt;/code&gt;, &lt;code&gt;仓库需要认证登陆&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仓库连接不上: 检查仓库地址, 检查网络.&lt;/li&gt;
&lt;li&gt;资源无法连接又没有response: 这种通常会在上面打出的日志中体现, 请求一个 url 便没有响应.&lt;/li&gt;
&lt;li&gt;下载缓慢: 更换仓库, 或者忍耐下第一次, 以后会好很多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 IDEA 刷新有问题时, 可以执行这个命令debug, 一般这个命令能成功, 那么 IDEA 刷新通常也能成功. (请注意版本问题, 命令行里执行的 gradle 版本需要跟 IDEA 里配置的 gradle 版本一致)&lt;/p&gt;
&lt;h3&gt;私服使用和包管理混乱引起的问题&lt;/h3&gt;
&lt;p&gt;私服使用中会有以下问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不稳定, 偶尔服务无响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置出错, 无法 proxy maven 主仓库. 或者出现私服中存在第三方包但是却不完整到时无法下载.&lt;/p&gt;
&lt;p&gt;一般来说会尝试把第三方仓库配置到私服之前:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;maven {
  url &amp;quot;http://maven.aliyun.com/nexus/content/groups/public&amp;quot;
}

maven {
  url &amp;quot;http://你家私服地址/&amp;quot;
  credentials {
    username &amp;quot;xxx&amp;quot;
    password &amp;quot;xxx&amp;quot;
  }
  authentication {
  	basic(BasicAuthentication)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样先去第三方查找, 再到私服查找.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;私服有认证. 可以参照第二条私服的认证方式. 其中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  authentication {
  	basic(BasicAuthentication)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是可选填的, 不填的话会自动识别认证方式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包方式不完整. 有的同学上传包的时候虽然包含了编译后的jar包, pom文件, 但是有时却没有把source包上传, gradle 默认是会下载source的, 如果没有, 私服返回404还好, 最怕会卡主(遇到过私服虽然没有这个文件却迟迟不返回response的情况.), 所以, 如果遇到这种问题, 可以:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;idea {
	module {
		downloadJavadoc = false
		downloadSources = false
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不让 IDEA 刷新的时候下载源码和文档, 万不得已还是不要用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;常用命令或参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--refresh-dependencies&lt;/code&gt;   刷新依赖，刷新那些SNAPSHOT的依赖，类似于 maven 的 -U 参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradle tasks&lt;/code&gt; 列出所有可执行的task&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradle tasks --all&lt;/code&gt; 列出所有可执行的task, 并附加上 mudole&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradle help --task taskName&lt;/code&gt;  查看一个task的帮助, 不过并不是所有task都有, 因为task都是可以自己来实现的.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradle idea -id&lt;/code&gt; 用来debug IDEA进行刷新时遇到的问题, 一般这个任务能成功, 刷新就能成功. 注意使用的 gradle 版本要一致.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--no-daemon&lt;/code&gt; 不是使用daemon进行构建. daemon的作用是不用每次 build 都再启动一个进程, 节省时间. 但却会在我们 debug 问题的时候不停的生产日志, 产生干扰.&lt;/p&gt;
&lt;h3&gt;依赖冲突处理&lt;/h3&gt;
&lt;p&gt;可以通过命令来查看一个项目的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gradle webapp:dependencies --configuration=compile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同于maven的&lt;strong&gt;最近&lt;/strong&gt;原则，gradle 依赖使用的是&lt;strong&gt;最新&lt;/strong&gt;原则. 比如你构建处于依赖顶层的 module , 那么版本会优先使用这个顶层module 的&lt;code&gt;build.grale&lt;/code&gt; 中定义的版本. 所以可以在顶层module 中强制定义版本&lt;/p&gt;
&lt;p&gt;依赖排除, 通常可以使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile(&amp;quot;org.springframework.boot:spring-boot-starter-web&amp;quot;) {
    exclude module: &amp;quot;spring-boot-starter-logging&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的语法, 还有更为粗暴直接的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;configurations {
    all*.exclude group: &apos;ch.qos.logback&apos;, module: &apos;logback-classic&apos;
    all*.exclude group: &apos;ch.qos.logback&apos;, module: &apos;logback-core&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;官方文档相当的详细，且附有很多example，配合 gradle 安装包里的 example 源文件阅读&lt;/p&gt;
&lt;h2&gt;交流&lt;/h2&gt;
&lt;p&gt;欢迎加入群 536890082，gradle，spring，activiti 交流&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Java web 项目异常设计实践</title>
      <link>http://blog.yangxiaochen.com/blog/java/异常实践.html</link>
      <pubDate>星期一, 10 七月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/异常实践.html</guid>
      	<description>
	&lt;h1&gt;异常实践&lt;/h1&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文是我在项目中设计和处理异常的一些实践，主要是围绕着常见的web项目，欢迎大家指正。&lt;/p&gt;
&lt;p&gt;本文分为两个个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异常设计&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2&gt;异常设计&lt;/h2&gt;
&lt;p&gt;通常考虑异常设计时大致分为三个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口层&lt;/li&gt;
&lt;li&gt;业务层&lt;/li&gt;
&lt;li&gt;类库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接口层就是我们通常说的 controller 层，以及提供 rpc 服务的接口层。&lt;/p&gt;
&lt;p&gt;业务层就是主要的业务代码模块，主要是 service 层。&lt;/p&gt;
&lt;p&gt;类库主要是指一些公共模块，可以在各个项目中使用的，比如 json，分布式锁等。&lt;/p&gt;
&lt;h3&gt;业务层&lt;/h3&gt;
&lt;p&gt;在业务层，我们主要是要设计&lt;strong&gt;业务异常&lt;/strong&gt;。什么是业务异常？业务异常就是我们能够人为的判断出业务逻辑走到某一个位置是不对的。比如，我们要根据一个 uid 来修改一个 user 的 name，但我们发现并没有这个 uid 对应的 user 数据，这时候就应该抛出一个业务异常。在发生业务异常时，要避免抛出 npe，RuntimeException 等其他内置异常，以方便上层来分辨到底是业务错误还是程序 bug。&lt;/p&gt;
&lt;p&gt;我一般会设计一个业务异常的基类 &lt;code&gt;ServiceException&lt;/code&gt;，将所有业务异常以这种类型来抛出，并带有必要的 message。&lt;/p&gt;
&lt;p&gt;为了把用户可读的消息和开发人员可读的消息区别开，&lt;code&gt;ServiceException&lt;/code&gt; 还需要实现一个接口 &lt;code&gt;UserMessage&lt;/code&gt;，并实现其中方法 &lt;code&gt;getUserMessage()&lt;/code&gt;来返回用户可读的信息，而 getMessage() 可以携带更详细的开发人员可读的错误信息&lt;/p&gt;
&lt;p&gt;设计一个 &lt;code&gt;ServiceErrorException&lt;/code&gt;，继承 &lt;code&gt;ServiceException&lt;/code&gt;。&lt;code&gt;ServiceErrorException&lt;/code&gt; 的主要目的是为了表明这个异常的错误程度高，需要记录 error。&lt;/p&gt;
&lt;p&gt;以上就定型了业务异常的基本结构，上面一些特殊设计会在&lt;strong&gt;异常处理&lt;/strong&gt;中用到，我们后面来说，再做前后对照。我们可以根据需要来实现若干子类来表示业务层中不同模块的错误。&lt;/p&gt;
&lt;h3&gt;接口层&lt;/h3&gt;
&lt;p&gt;对于接口层，特别是rpc调用，比如我们的dubbo调用，需要把api的jar包放在调用方。我们需要把异常类给包括进去，但调用方不能也不应该拿到我们业务层的 &lt;code&gt;ServiceException&lt;/code&gt;，所以需要在接口层定义新的业务异常类型，比如，就叫&lt;code&gt;ApiServiceException&lt;/code&gt;，放在api的jar包里给调用方。&lt;/p&gt;
&lt;p&gt;接口实现需要把业务层的&lt;code&gt;ServiceException&lt;/code&gt;给catch到，重新封装为&lt;code&gt;ApiServiceException&lt;/code&gt;抛出。&lt;/p&gt;
&lt;p&gt;这样，调用方在判断调用时发生的异常时，有三种可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rpc框架异常。比如又dubbo框架抛出的异常，这一版两种可能：1. 网络异常，我们需要重试；2. 调用未能达成，这种一般是接口没有匹配上，在开发测试时都可以发现的错误，改掉即可。所以，当发生rpc框架异常时，调用方的策略就应该是重试。&lt;/li&gt;
&lt;li&gt;ApiServiceException。这表示被调用方出现了业务异常，调用方也需要作为业务异常来处理。&lt;/li&gt;
&lt;li&gt;其他异常。这表示被调用方的程序有bug报出了异常透传给了调用方，这是调用方应及时联系接口实现方来修补bug。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上，就能够分类准确应对rpc过程中的异常情况。&lt;/p&gt;
&lt;p&gt;http方式的接口层也可以这么做，不过由于api并不对外，所以也可以完全由自身来处理异常类型，详见&lt;strong&gt;异常处理&lt;/strong&gt;部分。&lt;/p&gt;
&lt;h3&gt;类库&lt;/h3&gt;
&lt;p&gt;作为类库，因为通常没有业务意义，所以在发生逻辑上的异常时，根本不可能知道需要怎么处理，这就需要直接向上抛出，到交给业务层处理。&lt;/p&gt;
&lt;p&gt;类库需要将自身的逻辑上的异常，同一封装。比如，处理 Json 的类库，异常最终抛出时，都被封装成为&lt;code&gt;JsonParseException&lt;/code&gt; 或 &lt;code&gt;JsonSerializeExcption&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样调用方使用类库时，异常会有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类库封装的自定义异常。这种是调用时出现的逻辑错误，调用方以业务异常来处理。&lt;/li&gt;
&lt;li&gt;其他异常。可以认为是类库bug。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;p&gt;有了以上的异常设计，那么处理时就可以按照以下流程。&lt;/p&gt;
&lt;p&gt;以 http 请求的 ExceptionHandler 为例，所有 http 请求异常都会放在这里处理，过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ex 异常传入。&lt;/li&gt;
&lt;li&gt;装饰 ex 异常，&lt;code&gt;ex = new WebApiException(...,ex)&lt;/code&gt;，其包含有 &lt;code&gt;message&lt;/code&gt;，&lt;code&gt;isLogError&lt;/code&gt; 属性
&lt;ol&gt;
&lt;li&gt;如果 ex 是非 &lt;code&gt;ServiceException&lt;/code&gt;，那么&lt;code&gt;message = “系统内部错误”&lt;/code&gt;，&lt;code&gt;isLogError = true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 ex 是 &lt;code&gt;ServiceException&lt;/code&gt;，那么&lt;code&gt;message = ex.getUserMessage()&lt;/code&gt;；更进一步，如果是 &lt;code&gt;ServiceErrorException&lt;/code&gt;，那么&lt;code&gt;isLogError = true&lt;/code&gt;，否则 &lt;code&gt;isLogError = false&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;ex.isLogError == true&lt;/code&gt;，记录 error log，否则，记录 warn log。&lt;/li&gt;
&lt;li&gt;判断 http 请求是页面请求，还是ajax请求。
&lt;ol&gt;
&lt;li&gt;如果是页面请求。500转错误页，显示 &lt;code&gt;ex.getMessage()&lt;/code&gt;，如果是debug环境或者是请求带有debug参数，也把错误堆栈输出在页面上。&lt;/li&gt;
&lt;li&gt;如果是 ajax 请求。返回表示错误的 json 消息，同样，如果是debug环境或者是请求带有debug参数，消息中带上堆栈信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上，就是一个简单而有效的异常处理机制。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;以上是我的个人实践经验总结，请各位批评指正，欢迎讨论。&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>spring &amp; spring mvc 初始化介绍</title>
      <link>http://blog.yangxiaochen.com/blog/java/spring & spring mvc 初始化介绍.html</link>
      <pubDate>星期四, 30 三月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/spring & spring mvc 初始化介绍.html</guid>
      	<description>
	&lt;!-- # spring &amp; spring mvc 初始化介绍 --&gt;
&lt;h2&gt;web项目的结构&lt;/h2&gt;
&lt;h3&gt;java servlet 技术&lt;/h3&gt;
&lt;p&gt;java servlet 技术是 java 的一个 web 服务规范, 提供了统一的 servlet api 供各个容器厂商实现, 以保证一个 java web 项目可以运行在不同厂商的服务器下.&lt;/p&gt;
&lt;p&gt;请看实例简单复习下 servlet, listner, filter&lt;/p&gt;
&lt;p&gt;listner, filter 会在 web 容器启动时执行 init 方法&lt;/p&gt;
&lt;p&gt;servlet 会在第一次访问时进行初始化. 当然也可以设置 init on start&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3&gt;非 servlet 规范的 java web 项目&lt;/h3&gt;
&lt;p&gt;使用netty作为服务器lib, 加入 http 协议的处理层,  自行完成处理 http 请求读写&lt;/p&gt;
&lt;h3&gt;spring mvc 的的封装&lt;/h3&gt;
&lt;p&gt;我们最常用到的 spring mvc 框架就是对 servlet 技术的封装, 在 web.xml 中加入实现 &lt;code&gt;Listenner&lt;/code&gt; 的 &lt;code&gt;SpringContextListener&lt;/code&gt; 和实现了 &lt;code&gt;Servlet&lt;/code&gt; 的 &lt;code&gt;DispatcherServlet&lt;/code&gt;, 来对spring 和 spring mvc 进行初始化.&lt;/p&gt;
&lt;h2&gt;spring context 结构&lt;/h2&gt;
&lt;p&gt;spring context 是整个 spring 的核心, 通常也被叫做 spring 容器. 通常讲的 spring 初始化过程, 就是初始化 spring context 的过程.&lt;/p&gt;
&lt;p&gt;根据应用不同, 使用的 spring  context 类型也不同&lt;/p&gt;
&lt;h3&gt;继承树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/context继承.png&quot; alt=&quot;context继承.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;常见的 war 包形式的 web 应用, 使用的是 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;spring boot 默认使用的是 &lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;重要组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 通用组件, 负责 bean 注册和初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Environment&lt;/code&gt; 通用组件 , 包含系统参数, 启动参数等. 还有对启动参数解析后的属性, 比如 profile&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ApplicationListener&lt;/code&gt;s 通用组件, 保存注册进来的context事件listener&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些 context 状态标志, parent&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ServletContext&lt;/code&gt;, &lt;code&gt;ServletConfig&lt;/code&gt; WebApplicationContext类里特有的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些特定的参数. 在特定context类型中, 比如&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/** Default config location for the root context */
public static final String DEFAULT_CONFIG_LOCATION = &amp;quot;/WEB-INF/applicationContext.xml&amp;quot;;

/** Default prefix for building a config location for a namespace */
public static final String DEFAULT_CONFIG_LOCATION_PREFIX = &amp;quot;/WEB-INF/&amp;quot;;

/** Default suffix for building a config location for a namespace */
public static final String DEFAULT_CONFIG_LOCATION_SUFFIX = &amp;quot;.xml&amp;quot;;	
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;spring context 初始化过程概念概览&lt;/h2&gt;
&lt;p&gt;一个 spring context 的初始化过程大致分为以下几个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取并设置系统参数, 环境变量, 获取一些初始化 context 需要的组件, 比如 ApplicationContextInitializer 等.&lt;/p&gt;
&lt;p&gt;这个属于context 初始化的前置逻辑, 由应用自己控制, 我们也可自己来写, 用来给后面 context 初始化做准备&lt;/p&gt;
&lt;p&gt;这一步根据应用不同差别很大, 比如传统 war 包的 ContextLoadListner 和 spring boot 的 SpringApplication 中的逻辑就很不同.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create context&lt;/p&gt;
&lt;p&gt;根据应用不通, 创建不同的 context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configure context&lt;/p&gt;
&lt;p&gt;用第1步获得的参数和组件, 来配置创建好的 context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;context.refresh&lt;/p&gt;
&lt;p&gt;核心步骤, context 初始化的具体过程就在这里.&lt;/p&gt;
&lt;p&gt;包括分门别类的加载各种特殊的 bean, 然后加载普通的ben&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;spring 初始化过程实例概览(非 spring boot 的传统war包)&lt;/h2&gt;
&lt;h3&gt;ContextLoaderListener&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ContextLoaderListener&lt;/code&gt; 配置在 web.xml 中, 在容器启动时初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/ContextLoaderListener.png&quot; alt=&quot;ContextLoaderListener.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;部分较为重要步骤解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;决定spring web app context类型. 不指定的情况下默认策略创建 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;16&quot;&gt;
&lt;li&gt;以 bean 的 configuration 文件, 就是一般我们说的xml文件 为入口, 加载 &lt;code&gt;BeanDefinition&lt;/code&gt; 到 bean factory. 注意仅仅是加载 bean 的描述, 而没有实例化这些 bean&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;17&quot;&gt;
&lt;li&gt;实例化执行所有的 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;, 从 &lt;code&gt;BeanDefinition&lt;/code&gt; 中和 context 的 &lt;code&gt;beanFactoryPostProcessors&lt;/code&gt; 字段中查找.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;是意图在 bean factory 加载了所有定义的 bean 定义之后, 且在这些 bean 实例化之前, 做一些操作.&lt;/p&gt;
&lt;p&gt;这一步通常在调用各个 processor 时, 产生新的 bean 定义到 bean factory&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;18&quot;&gt;
&lt;li&gt;注册 &lt;code&gt;BeanPostProcessor&lt;/code&gt; , 从 &lt;code&gt;BeanDefinition&lt;/code&gt; 中查找.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 会在之后每个 bean 实例化之后调用, 用来对 bean 做一些其他操作, 比如放入一些参数:&lt;/p&gt;
&lt;p&gt;像 &lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt; 的作用就是注入 &lt;code&gt;@Autowired&lt;/code&gt; 字段.&lt;/p&gt;
&lt;p&gt;生成动态代理对象也是通过  &lt;code&gt;BeanPostProcessor&lt;/code&gt; 实现的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;21&quot;&gt;
&lt;li&gt;&lt;code&gt;onRefresh&lt;/code&gt; 是用来初始化其他的特殊的 bean, 这部分逻辑通常在特殊的 context 子类实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如在 spring boot 中使用的 &lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt; 中, 会在这里初始化并启动内嵌服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;22&quot;&gt;
&lt;li&gt;将在  &lt;code&gt;BeanDefinition&lt;/code&gt; 中的, 还有之前设置到context属性中的  &lt;code&gt;ApplicationListener&lt;/code&gt; 加到广播列表中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;23&quot;&gt;
&lt;li&gt;将  &lt;code&gt;BeanDefinition&lt;/code&gt;  中其他的非懒加载的 bean 实例化.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;24&quot;&gt;
&lt;li&gt;实例化并调用 &lt;code&gt;LifecycleProcessor&lt;/code&gt; , 然后广播 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;26&quot;&gt;
&lt;li&gt;将 context 放到 &lt;code&gt;ServletContext&lt;/code&gt; 的 attribute 属性里, 之后 &lt;code&gt;DispatcherServlet&lt;/code&gt; 初始化会用到&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;*以上说的 bean 均为 singleton 的 scope&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;DispatcherServlet&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 配置在 web.xml 中, 在第一次访问时初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/DispatcherServlet.png&quot; alt=&quot;DispatcherServlet.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;部分较为重要步骤解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;以 &lt;code&gt;ContextLoaderListener&lt;/code&gt;创建的 context 为 parent, 创建新的 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;创建一个 &lt;code&gt;ContextRefreshListener&lt;/code&gt; , 加入到 context 中, 监听 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;refresh 过程跟&lt;code&gt;ContextLoaderListener&lt;/code&gt; 一样, 不同的是在查找 bean 时, 能够查到 parent context 的 bean, 供新的 context 初始化使用.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;触发  &lt;code&gt;ContextRefreshedEvent&lt;/code&gt; , 初始化 spring mvc 的组件, 添加到 &lt;code&gt;DispatcherServlet&lt;/code&gt; 中.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一些特殊类型Bean的初始化时机 (待完善, 请持续补充)&lt;/h2&gt;
&lt;h3&gt;BeanFactoryPostProccesor&lt;/h3&gt;
&lt;p&gt;context refresh 之后, 初始化好 factory 之后, 会先执行 context 自身的 factory post 操作, 然后就会执行  &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt;  这种类型 bean 所定义的 factory post 操作.&lt;/p&gt;
&lt;h3&gt;BeanDefinitionRegistryPostProcessor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 的子类, 执行优先级比 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 要高. 通常可以通过 order 来控制&lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt; 类型的执行顺序, 还跟这个 bean 定义的时机有关, 在 prepare context 阶段定义的总会最先执行.&lt;/p&gt;
&lt;p&gt;通常自定义的 xml 和 bean 配置 会在这个阶段被定义到 factory.&lt;/p&gt;
&lt;h3&gt;BeanPostProccesor&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 都执行完之后实例化, 并 apply 到 factory ,  在一个 bean 初始化之后会被调用.&lt;/p&gt;
&lt;h3&gt;Aware&lt;/h3&gt;
&lt;p&gt;如 &lt;code&gt;ApplicationContextAware&lt;/code&gt; , 实现这个接口的 bean 会由一个 &lt;code&gt;BeanPostProccesor&lt;/code&gt; 类型的  &lt;code&gt;ApplicationContextAwareProcessor&lt;/code&gt; 在初始化之后 set 一个 application context&lt;/p&gt;
&lt;p&gt;Aware 相关类的很多, 都类似&lt;/p&gt;
&lt;h3&gt;ApplicationListener&lt;/h3&gt;
&lt;p&gt;用来监听 context 生命周期中各个事件的类, 可以在 prepare 和 refresh 阶段注入&lt;/p&gt;
&lt;h3&gt;ApplicationContextInitializer&lt;/h3&gt;
&lt;p&gt;prepare context 阶段执行, 在 context refresh之前执行. 可以对 context 注入 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 和 &lt;code&gt;ApplicationListener&lt;/code&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Java异常规范</title>
      <link>http://blog.yangxiaochen.com/blog/java/异常规范.html</link>
      <pubDate>星期四, 29 九月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/异常规范.html</guid>
      	<description>
	&lt;h1&gt;异常规范&lt;/h1&gt;
&lt;h2&gt;异常介绍&lt;/h2&gt;
&lt;h4&gt;Throwable&lt;/h4&gt;
&lt;p&gt;所有Exception和Error的父类.&lt;/p&gt;
&lt;h4&gt;Error&lt;/h4&gt;
&lt;p&gt;致命错误. 项目自身存在问题, 诸如格式有问题, 编译版本不对, 堆栈溢出等, 项目在出现ERROR的情况下是不应该运行的. 同时, 程序遇到Error时, 程序不需要, 通常也是没有能力做处理的, 只能够停止程序针对项目或者运行环境做人工处理才行.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4&gt;Exception&lt;/h4&gt;
&lt;p&gt;区别于Error, 是程序可以自己处理的异常. Exception的子类中, 特殊的RuntimeException被称为&lt;strong&gt;运行时异常&lt;/strong&gt;, 也叫&lt;strong&gt;非受检异常&lt;/strong&gt;; 其他的子类包括Exception类本身都叫&lt;strong&gt;受检异常&lt;/strong&gt;&lt;/p&gt;
&lt;h5&gt;受检异常&lt;/h5&gt;
&lt;p&gt;Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。&lt;/p&gt;
&lt;h5&gt;非受检异常(运行时异常)&lt;/h5&gt;
&lt;p&gt;不需要强制catch或者throw的异常.&lt;/p&gt;
&lt;h2&gt;程序中如何使用异常&lt;/h2&gt;
&lt;p&gt;程序中我们主要关注&lt;strong&gt;受检异常&lt;/strong&gt;和&lt;strong&gt;运行时异常&lt;/strong&gt;的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些原则, 这些原则并不独立, 互相之间有照应或者补充:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发生可恢复错误的抛出受检异常，程序错误就抛出运行时异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用运行时异常. 从保障代码简洁, 清晰, 有意义的角度上来说.&lt;/p&gt;
&lt;p&gt;注意绝对不是无脑把受检异常换为运行时异常.&lt;/p&gt;
&lt;p&gt;很多时候我们要延迟处理异常: 比如我们的一个受检异常在层次很深的地方抛出, 但是我们在代码层次很高的地方才能做处理, 那么受检异常会出现在代码调用的每一层. 这非常繁琐, 也不清晰.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谨慎抛出受检异常.&lt;/p&gt;
&lt;p&gt;受检异常是不受欢迎的.&lt;/p&gt;
&lt;p&gt;除非你认为你是在强调这个异常, 调用者在大多数情况下需要重点关注这个异常并catch这个异常并做处理.&lt;/p&gt;
&lt;p&gt;使用运行时异常带来的简洁并不能够弥补开发人员忽略了这个异常带来的问题时.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为定位是类库的模块, 尽量使用运行时异常, 并对java低层异常封装, 抛出类库特有的概括性的异常.&lt;/p&gt;
&lt;p&gt;当站在调用者的角度, 可以获悉这个类库有哪几种异常, 出现时代表什么了.&lt;/p&gt;
&lt;p&gt;移位类库的调用很多时候跟业务没有关系, 当出现错误时, 通常是因为我们的代码漏洞造成的, 这并不能简单通过try_catch进行恢复, 所以尽量不使用受检异常.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为定位是服务的模块, 可以使用一些受检异常.&lt;/p&gt;
&lt;p&gt;因为当调用服务出现错误, 一般是一个可以解释的业务错误, 如果是想要调用者非常注意的错误, 可以使用受检异常.&lt;/p&gt;
&lt;p&gt;服务的调用一般代码层次比较浅, 并且是和业务比较相关的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务异常需要单独封装成新的异常来表达一类或者一个模块的业务错误, 可以使用受检异常. 但也参照1, 2, 3&lt;/p&gt;
&lt;p&gt;可以把一些非业务异常封装成为业务异常, 如果你知道在这个地方这种非业务异常在业务上可以表达一些含义.&lt;/p&gt;
&lt;p&gt;比如某个位置抛出了json解析异常, 我们可以说传入的某个数据格式是错误的.&lt;/p&gt;
&lt;p&gt;为了给大家建立异常体系结构, 业务异常定义为受检异常, 强制让大家关注下.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非业务异常, 代码底层异常, 如果出现的话可以定义为代码bug的, 使用运行时异常&lt;/p&gt;
&lt;p&gt;即使没有catch住的后果是在系统运行时抛给了用户, 也不应该catch. 当然在项目中需要一个最高层次的异常处理, 对非业务异常统一catch记录报警而不要暴露给用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务异常如果可以, 不要跨层(跨模块)&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;controller -&amp;gt; service -&amp;gt; adaptor -&amp;gt; UC dubbo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UC dubbo 抛出的异常, 应该在adaptor或者service做处理封装新的异常, 不要让controller直面UC dubbo的异常.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常应该携带更多信息.&lt;/p&gt;
&lt;p&gt;尤其对业务异常来说, 知道异常发生时的业务数据是很重要的, 方便查找定位问题.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在api层(controller层), 将一些业务异常封装为API异常, 这类异常将直接给用户api异常的提示, 且有时可以认为这些异常是正常的, 不需要报警的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效的业务异常类划分和异常code定义, 有助于统一处理异常时区别异常的等级合适否需要报警.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在设计异常时请考虑这一点.&lt;/p&gt;
&lt;ol start=&quot;12&quot;&gt;
&lt;li&gt;如果不知道自己的异常应该是使用受检异常还是运行时异常, 使用运行时异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先报出错误, 不做对未知的设计&lt;/p&gt;
&lt;h2&gt;如何处理异常&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;绝对禁止catch后什么都不做!&lt;/li&gt;
&lt;li&gt;在catch之后封装成新异常抛出的时候, 不要记录日志. 因为你抛出了, 会有上层来处理记录日志, 只要没有1这种情况, 总会有信息的. 这里再记录日志就重复了.&lt;/li&gt;
&lt;li&gt;在需要时一定要使用上finally&lt;/li&gt;
&lt;li&gt;处理异常时记录的日志一般要把异常的堆栈给记录下来.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;具体实施方案&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有类库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/fn-commons&quot;&gt;fn-commons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/common-search&quot;&gt;common-search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/api-common&quot;&gt;api-common&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个项目, master打tag, 切新版本分支, 升级大版本, 例如1.0 -&amp;gt; 2.0&lt;/p&gt;
&lt;p&gt;目标: 基本都是用运行时异常,减轻调用负担, 看情况决定是否自定义异常. 类库尽量少记log, 尤其不能记info的log. 这个出log规范的时候再说&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重点项目&lt;a href=&quot;http://git.lianjia.com/fnrd/fnrd-gte&quot;&gt;fnrd-gte&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;切个exception-refactor分支&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新类库依赖. 更改由依赖更新引起的代码错误.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中在service包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;adaptor&lt;/p&gt;
&lt;p&gt;新建一个RPCException, 继承RuntimeException, 替换现有的直接用RuntimeException抛出.&lt;/p&gt;
&lt;p&gt;RPCException可以带一些请求参数信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api包&lt;/p&gt;
&lt;p&gt;强烈建议使用&lt;a href=&quot;http://git.lianjia.com/fnrd/api-common&quot;&gt;api-common&lt;/a&gt;, 不过涉及较多, 可以逐步改改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;impl包, 核心流程逻辑&lt;/p&gt;
&lt;p&gt;重点处理的位置, 挨个文件看, 然后从低向上重构&lt;/p&gt;
&lt;p&gt;定义FlowException作为主要流程业务异常, 统一处理时将会使用其中msg通知用户, &lt;strong&gt;非FlowException将会统一封装友好提示&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;可以定义更加细致的异常继承FlowException异常, 以应对更细致的需要.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;event, listner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易, 金融业务相关的增删改查service等.&lt;/p&gt;
&lt;p&gt;可以新定义FnServiceExcetion, TeServiceException, 也作为一类业务异常.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;controller&lt;/p&gt;
&lt;p&gt;选择性的对一些异常封装, WebApiException, msg直接给用户显示.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

	</description>
    </item>
    <item>
      <title>git实际开发语句</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-in-use.html</link>
      <pubDate>星期一, 4 七月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/git/git-in-use.html</guid>
      	<description>
	&lt;!-- # git实际使用指南 --&gt;
&lt;h2&gt;dev上工作git指南&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切到&lt;code&gt;dev&lt;/code&gt;分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git checkout dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git checkout -b bug/JRTE-333-问题描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git checkout -b feature/JRTE-333-需求描述
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .....
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;提交分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git push origin [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发起&lt;code&gt;merge request&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 登陆git.lianjia.com发起
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一切正常, 就结束了. 如果发现&lt;code&gt;merge request&lt;/code&gt;有冲突, 不能合并, 转 &lt;code&gt;7&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;merge request&lt;/code&gt;有冲突&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换到&lt;code&gt;dev&lt;/code&gt;, 更新之.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git co dev
 git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切回你的分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git co [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rebase! 难以理解而又复杂的一步. 但做过一次你就会了!&lt;/p&gt;
&lt;p&gt;进行rebase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git rebase dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git rebase dev&lt;/code&gt; 的意思是将&lt;code&gt;你的分支&lt;/code&gt;上的每一次提交, 应用到&lt;code&gt;dev&lt;/code&gt;分支的尾部.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果提示有冲突, 转&lt;code&gt;7.5&lt;/code&gt;. 如果没有冲突:&lt;/p&gt;
&lt;p&gt;因为你push过你的分支, 所以&lt;code&gt;远程你的分支&lt;/code&gt;和&lt;code&gt;本地你的分支&lt;/code&gt;已经不一致了. 所以强行覆盖&lt;code&gt;你的远程分支&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git push -f origin [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你就发现你的&lt;code&gt;merge request&lt;/code&gt;显示可以自动合并了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冲突, 然后根据提示执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git add [冲突文件]
 git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果还有冲突, 转&lt;code&gt;7.5&lt;/code&gt;, 如果没有, 转&lt;code&gt;7.4&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如果出现以下情况, 很有可能你就错了&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把&lt;code&gt;dev&lt;/code&gt;上的代码merge到分支:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  git merge dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;dev&lt;/code&gt;上merge分支代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在dev上执行&lt;code&gt;git pull&lt;/code&gt;发现不是&lt;code&gt;fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在任何分支上执行&lt;code&gt;git pull&lt;/code&gt;发现不是&lt;code&gt;fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;合并为一次提交&lt;/h2&gt;
&lt;h3&gt;方法一&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git reset [分支开始version]
git add .
git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法二, 保证没有冲突, 且合并为一次提交!&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;4. 提交分支&lt;/code&gt; 时, 先更新&lt;code&gt;dev分支&lt;/code&gt;, 然后在&lt;code&gt;你的分支&lt;/code&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase dev -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把除了第一个&lt;code&gt;pick&lt;/code&gt;全改成&lt;code&gt;s&lt;/code&gt;或者&lt;code&gt;squash&lt;/code&gt;. 提示很全, 试试吧.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>git分支管理与使用规范</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-in-action.html</link>
      <pubDate>星期二, 21 六月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/git/git-in-action.html</guid>
      	<description>
	&lt;!-- # git分支管理与使用规范 --&gt;
&lt;h2&gt;分支管理&lt;/h2&gt;
&lt;h3&gt;flow&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git flow&lt;/li&gt;
&lt;li&gt;github flow&lt;/li&gt;
&lt;li&gt;gitlab flow&lt;/li&gt;
&lt;li&gt;fn flow&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h3&gt;分支与开发定义&lt;/h3&gt;
&lt;h4&gt;主要分支&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;master&lt;/p&gt;
&lt;p&gt;线上分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;develop&lt;/p&gt;
&lt;p&gt;常规开发分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;masterfix&lt;/p&gt;
&lt;p&gt;线上bug修改分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;辅助分支&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;feature/*&lt;/p&gt;
&lt;p&gt;功能开发分支, 从develop分支而来, 然后合并入develop, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;release/*&lt;/p&gt;
&lt;p&gt;上线分支, 从develop分支而来, 然后合并入master, 并应用到develop, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hotfix/*&lt;/p&gt;
&lt;p&gt;线上bug修改分支, 从masterfix分支而来, 然后合并入masterfix, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;如何使用各种分支&lt;/h3&gt;
&lt;h4&gt;init&lt;/h4&gt;
&lt;p&gt;一个项目初始有master分支, 需要新建立一个develop分支和masterfix分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git br -b develop 
git push origin develop

git br -b masterfix
git push origin masterfix
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;feature&lt;/h4&gt;
&lt;p&gt;常规功能开发需要从develop分支checkout出feature分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b feature/GET-1008-添加用户查询列表 [develop]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发完毕后合并回develop分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git pull // 先更新develop
git merge feature/GET-1008-添加用户查询列表 --no-ff
git push origin develop

git branch -d feature/GET-1008-添加用户查询列表
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Release&lt;/h4&gt;
&lt;p&gt;开发完毕, 准备发布:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b release/1.0.0 [develop]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在发布分支上处理一些发布操作, 比如更改版本号, 上线前测试, 问题修改等等. 当分支可以进行上线发布后:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge release/1.0.0 --no-ff 
git tag -a 1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此release完成, 但是需要将在release分支上的修改应用到develop上.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git merge release/1.0.0 --no-ff

git branch -d release/1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后, 我们可以激活masterfix分支, 同步一下已经上线的master分支, 为修改将要出现的线上bug做准备&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout masterfix
git merge master // 在正常情况下, 这里一定是fast-faward
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;hotfix&lt;/h2&gt;
&lt;p&gt;当出现bug时, 我们需要从master或者是masterfix分支上分出hotfix分支来修改bug.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b hotfix/修改空指针 masterfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完毕后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout masterfix
git merge hotfix/修改空指针 --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;期间可以进行多次hotfix, 最后当masterfix测试后没有问题, 准备上线:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge masterfix --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在master上打下当前上线的tag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag -a 1.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样, 这些修改要应用到develop分支上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git merge masterfix --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;分支与环境对应?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;master    --  online&lt;/li&gt;
&lt;li&gt;release   --  off&lt;/li&gt;
&lt;li&gt;develop   --  ci&lt;/li&gt;
&lt;li&gt;masterfix --  online-bug-fix&lt;/li&gt;
&lt;li&gt;feature   --  local, dev&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;h2&gt;使用规范&lt;/h2&gt;
&lt;h3&gt;鼓励开分支&lt;/h3&gt;
&lt;p&gt;鼓励本地开分支开发, 独立功能独立分支.&lt;/p&gt;
&lt;h3&gt;将分支上提交合并&lt;/h3&gt;
&lt;p&gt;分支上开发的commit建议合并为一个commit, 这样易读, 方便主分支管理.&lt;/p&gt;
&lt;p&gt;一种最简单直接的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset [分支开始处]
git commit -m &amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方法, 在feature分支上执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i develop // 将feature分支的修改应用到develop上

// 后续操作
http://www.ruanyifeng.com/blog/2015/08/git-use-process.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;保留分支信息&lt;/h3&gt;
&lt;p&gt;在不同分支合并时使用 &lt;code&gt;--no-ff&lt;/code&gt; 参数生成merge commit&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commit e562022b423f7bf29f77927dea4d13cb05230681
Merge: d88f815 799b7f8
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:10:41 2016 +0800

    Merge branch &apos;feature/welcome&apos; into develop

commit 799b7f87b99d5f5c49acf2edd8a6a363ff44f29f
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:10:11 2016 +0800

    也修改auth

commit 18e7893f1583559003f7a4bb41fd03b937b3ed42
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:08:04 2016 +0800

    修改 auth
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;减少以及消除无意义的分支内merge&lt;/h3&gt;
&lt;p&gt;同一分支更新时要避免产生无意义的merge&lt;/p&gt;
&lt;p&gt;如果是一个人使用git-flow, 你会发现你所有的commit以及commit log都是有意义的. 你所有的更改, feature合并都是有明确记录的.&lt;/p&gt;
&lt;p&gt;但是在多人使用下, 大家各自在本地开发, 往develop分支上merge, 那么就会出现每个人的develop分支不一致. 那么当一个人把自己的develop分支push到远端时, 其他人pull的时候就会出现分支合并, 产生 &amp;quot;Merge branch &apos;develop&apos; of remote into develop&amp;quot; 的类似commit.&lt;/p&gt;
&lt;p&gt;很多时候, 合并时没有冲突, 自动完成. 这种merge产生的commit是没有意义的, 而且会让分支看起来混乱.&lt;/p&gt;
&lt;p&gt;按照以下规则可以减少甚至消除这种无意义的commit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地在往develop分支进行合并时, ** &lt;code&gt;先在develop上执行git pull&lt;/code&gt; **, 当你没有在本地对develop分支有commit时, 执行&lt;code&gt;git pull&lt;/code&gt;是会发生Fast-forward合并的, 这种默认并不产生commit.&lt;/li&gt;
&lt;li&gt;将feature合并到develop上.&lt;/li&gt;
&lt;li&gt;push develop. 将你的修改提交到远端.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多数时候, 如果多个人分开执行以上操作, 是不会有问题的.&lt;/p&gt;
&lt;p&gt;如果多个人同时进行以上操作, 那么在进行第三步的时候, 是push不上去的, 需要先pull, 那么又会产生所谓的无意义commit, 该怎么办呢:&lt;/p&gt;
&lt;p&gt;这时不要用&lt;code&gt;git pull&lt;/code&gt;来拉取更改, 改为使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将远端代develop拉下来, 然后从本地develop上跟远端develop分叉的地方开始, 将本地的commit一个个应用到远端develop的末端, 使之成为一条直线, 从而没有了merge commit.&lt;/p&gt;
&lt;p&gt;关于冲突, rebase的时候也会有冲突:&lt;/p&gt;
&lt;p&gt;比如远端 &lt;code&gt;a-&amp;gt;b-&amp;gt;c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你的 &lt;code&gt;a-&amp;gt;b-&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进行rebase之后 &lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;e&lt;/code&gt;, 其中&lt;code&gt;e&lt;/code&gt;的更改内容和log就是你的&lt;code&gt;d&lt;/code&gt;, 如果有冲突, 冲突的修改也是提现在&lt;code&gt;e&lt;/code&gt;中&lt;/p&gt;
&lt;h3&gt;冲突提交&lt;/h3&gt;
&lt;p&gt;修改完冲突, 我们会进行commit提交冲突修改. &lt;strong&gt;不要使用&lt;code&gt;git commit -m&lt;/code&gt;, 请直接使用&lt;code&gt;git commit&lt;/code&gt;, git会识别你这是一个冲突提交.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;常用操作&lt;/h3&gt;
&lt;p&gt;回滚
git reset --hard [version]  // 丢弃版本后的所有修改
git reset [version]         // 保留版本后的所有已提交修改
git reset --soft [version]  // 保留版本后的所有已提交修改到commit stage&lt;/p&gt;
&lt;p&gt;补充提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交tag到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志与diff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sourcetree // 软件
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-workflow.html&quot;&gt;Git 工作流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/08/git-use-process.html&quot;&gt;合并commit&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>git-flow实践</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-flow-in-action.html</link>
      <pubDate>星期日, 12 六月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/git/git-flow-in-action.html</guid>
      	<description>
	&lt;!-- # git-flow 操作实践 --&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;brew install git-flow
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2&gt;init&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ git flow init

Initialized empty Git repository in ~/project/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master]
Branch name for &amp;quot;next release&amp;quot; development: [develop]

How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时会在当前目录执行git init操作. 并且生成4个分支名字, 并且默认在develop分支上, develop分支就是我们主要工作的地方.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
* develop
master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们除了要把master分支推到远端仓库, develop同样也要推到远端仓库 &lt;code&gt;git push origin develop&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Feature branches&lt;/h2&gt;
&lt;p&gt;开始一个新功能添加, 或者是一般bug修复, 或者是其他功能. 我们需要开一个feature分支. 我们在本地的主要工作都是要开feature分支完成的. ** 不要在develop 分支上开发. **&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow feature start authentication
Switched to a new branch &apos;feature/authentication&apos;

Summary of actions:
- A new branch &apos;feature/authentication&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;feature/authentication&apos;

Now, start committing on your feature. When done, use:

    git flow feature finish authentication
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以做自己的修改了, 完成后, 需要将feature合并回develop分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow feature finish authentication
Switched to branch &apos;develop&apos;
Updating 9060376..00bafe4
Fast-forward
authentication.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 authentication.txt
Deleted branch feature/authentication (was 00bafe4).

Summary of actions:
- The feature branch &apos;feature/authentication&apos; was merged into &apos;develop&apos;
- Feature branch &apos;feature/authentication&apos; has been removed
- You are now on branch &apos;develop&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;多个开发者进行开发时, 会出现每个人本地的develop分支不一致的情况, 这样在每次拉取远端develop分支时, 会出现很多merge提交. 关于这个问题, 在最后的&lt;code&gt;减少以及消灭无用的merge commit&lt;/code&gt;章节中说明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;releases&lt;/h2&gt;
&lt;p&gt;在没有使用git-flow工具时, 发布是一件很繁琐的事情, 要保留一个用于releases的分支, 打tag等. 使用git-flow可以用简单命令解决.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow release start 0.1.0
Switched to a new branch &apos;release/0.1.0&apos;

Summary of actions:
- A new branch &apos;release/0.1.0&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;release/0.1.0&apos;

Follow-up actions:
- Bump the version number now!
- Start committing last-minute fixes in preparing your release
- When done, run:

    git flow release finish &apos;0.1.0&apos; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你将开始一个发布, 一般可以直接finishi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow release finish 0.1.0
Switched to branch &apos;master&apos;
Merge made by the &apos;recursive&apos; strategy.
authentication.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 authentication.txt
Deleted branch release/0.1.0 (was 1b26f7c).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Release branch has been merged into &apos;master&apos;
- The release was tagged &apos;0.1.0&apos;
- Release branch has been back-merged into &apos;develop&apos;
- Release branch &apos;release/0.1.0&apos; has been deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时develop分支回合并到master分支, 并打tag. 之后我们只要把master和tag都推到远端仓库即可.&lt;/p&gt;
&lt;h2&gt;Hotfixing production code&lt;/h2&gt;
&lt;p&gt;紧急bug修复, 在已经发布的代码上更正. 会从master开出hotfix分支, 然后合并回master, 也会合并回develop.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow hotfix start assets
Switched to a new branch &apos;hotfix/assets&apos;

Summary of actions:
- A new branch &apos;hotfix/assets&apos; was created, based on &apos;master&apos;
- You are now on branch &apos;hotfix/assets&apos;

Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:

    git flow hotfix finish &apos;assets&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后修改问题, 之后提交:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow hotfix finish assets
Switched to branch &apos;master&apos;
Merge made by the &apos;recursive&apos; strategy.
assets.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 assets.txt
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
assets.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 assets.txt
Deleted branch hotfix/assets (was 08edb94).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Hotfix branch has been merged into &apos;master&apos;
- The hotfix was tagged &apos;0.1.1&apos;
- Hotfix branch has been back-merged into &apos;develop&apos;
- Hotfix branch &apos;hotfix/assets&apos; has been deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在往下阅读之前, 你最好将以上的命令实践一遍, 感受git-flow的操作与分支流向. 推荐SourceTree来跟踪变化.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;减少以及消灭无用的merge commit&lt;/h2&gt;
&lt;p&gt;如果是一个人使用git-flow, 你会发现你所有的commit以及commit log都是有意义的. 你所有的更改, feature合并都是有明确记录的.&lt;/p&gt;
&lt;p&gt;但是在多人使用下, 大家各自在本地开发, 往develop分支上merge, 那么就会出现每个人的develop分支不一致. 那么当一个人把自己的develop分支push到远端时, 其他人pull的时候就会出现分支合并, 产生 &amp;quot;Merge branch &apos;develop&apos; of remote into develop&amp;quot; 的类似commit.&lt;/p&gt;
&lt;p&gt;很多时候, 合并时没有冲突, 自动完成. 这种merge产生的commit是没有意义的, 而且会让分支看起来混乱.&lt;/p&gt;
&lt;p&gt;按照以下规则可以减少甚至消除这种无意义的commit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地在往develop分支进行合并时, ** &lt;code&gt;先在develop上执行git pull&lt;/code&gt; **, 当你没有在本地对develop分支有commit时, 执行&lt;code&gt;git pull&lt;/code&gt;是会发生Fast-forward合并的, 这种默认并不产生commit.&lt;/li&gt;
&lt;li&gt;将feature合并到develop上.&lt;/li&gt;
&lt;li&gt;push develop. 将你的修改提交到远端.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多数时候, 如果多个人分开执行以上操作, 是不会有问题的.&lt;/p&gt;
&lt;p&gt;如果多个人同时进行以上操作, 那么在进行第三步的时候, 是push不上去的, 需要先pull, 那么又会产生所谓的无意义commit, 该怎么办呢:&lt;/p&gt;
&lt;p&gt;这时不要用&lt;code&gt;git pull&lt;/code&gt;来拉取更改, 改为使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将远端代develop拉下来, 然后从本地develop上跟远端develop分叉的地方开始, 将本地的commit一个个应用到远端develop的末端, 使之成为一条直线, 从而没有了merge commit.&lt;/p&gt;
&lt;p&gt;关于冲突, rebase的时候也会有冲突:&lt;/p&gt;
&lt;p&gt;比如远端 &lt;code&gt;a-&amp;gt;b-&amp;gt;c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你的 &lt;code&gt;a-&amp;gt;b-&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进行rebase之后 &lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;e&lt;/code&gt;, 其中&lt;code&gt;e&lt;/code&gt;的更改内容和log就是你的&lt;code&gt;d&lt;/code&gt;, 如果有冲突, 冲突的修改也是提现在&lt;code&gt;e&lt;/code&gt;中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改完冲突, 我们会进行commit提交冲突修改. &lt;strong&gt;不要使用&lt;code&gt;git commit -m&lt;/code&gt;, 请直接使用&lt;code&gt;git commit&lt;/code&gt;, git会识别你这是一个冲突提交.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当然, 操作的疏忽依然会产生无意义的commit, 但这并不致命, 注意就好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果真的要消灭无意义commit: 在你&lt;code&gt;git pull&lt;/code&gt;之后发现自动合并了, 那么用&lt;code&gt;git reset --hard [刚刚你本地的提交commit version]&lt;/code&gt;进行本地版本回滚, 然后再&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我对rebase的理解也不是很多, 以上只是应用中的使用体会, 肯定还存在很多没有想到的情况和处理不当的地方, 请大家多提出来指正, 共同讨论.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&quot;&gt;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-分支-分支的衍合&quot;&gt;https://git-scm.com/book/zh/v1/Git-分支-分支的衍合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

	</description>
    </item>
    <item>
      <title>从一个丢失的iphone看互联网信息安全</title>
      <link>http://blog.yangxiaochen.com/blog/secure/a-lost-iphone-secure.html</link>
      <pubDate>星期一, 4 四月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/secure/a-lost-iphone-secure.html</guid>
      	<description>
	&lt;!-- # 一个真实故事 --&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;妹子把手机丢了...是在上公交车时, 妹子第二个上车, 头一个上去的黑色羽绒服男上车后问师傅是否去XX地, 师傅说不去, 黑羽绒服男就又挤下了车. 上车坐定一会, 妹子就发现手机不见了. 再打关机. 妹子说上车前确定手机还在 ,可以肯定就是那个黑衣服男偷得.&lt;/p&gt;
&lt;p&gt;之后补卡, 改密码等等善后事宜暂且不表. 且说说后续一些列发展引起我对互联网安全的思考.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2&gt;开端&lt;/h2&gt;
&lt;p&gt;用iphone手机的用户都知道, 一个iphone由一个appleid激活, 如果不进行反激活, 是无法登陆其他appleid的. 所以妹子就打开了丢失模式. 当丢失的手机打开联网时定位并且锁定. 小偷不知道appleid的密码, 就无法解锁手机, 也就无法转手卖出.&lt;/p&gt;
&lt;p&gt;头几天鸟无音信.&lt;/p&gt;
&lt;p&gt;在一两周后, 妹子邮箱接连收到邮件, 内容大概是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您的iphone正在尝试解锁刷机, 如果是您操作, 请忽略; 如果不是您操作, 请登录&lt;a href=&quot;#&quot;&gt;Apple ID 服务中心&lt;/a&gt;进行取消操作. 该操作将在12小时后被允许.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;署名是 &lt;code&gt;Apple ID Service&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;还好妹子是对这种事情无从下手, 问我怎么办, 我比较警惕, 说转发给我, 我接到后打开, 发现这个邮件的格式和内容很正式. 但是很明显有以下几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邮件来源地址不是&lt;code&gt;apple.com&lt;/code&gt;, 而是一个其他的地址.&lt;/li&gt;
&lt;li&gt;邮件中登陆Apple ID 中心的链接也不是官方的.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开这个链接, 是个和&lt;code&gt;查找 iphone&lt;/code&gt;登录界面完全一样的页面. 当然, 这是个伪造的钓鱼网站, 如果妹子自己打开这个并输入了appleid和密码, 那么账号密码就已经陷落了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意: 如果是手机邮箱, 那么发件人的地址默认是隐藏的. 而且, 打开链接后网页的url也是隐藏的. 所以, 如果是手机打开邮件, 很难分辨真假.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见, 被偷iphone手机, 由于其激活机制的特殊性, 产生了一条很色的产业链:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小偷 -&amp;gt; 网络诈骗技术者
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小偷偷到手机后, 无法解锁, 只能卖给下线. 下线是大型的收购商, 来收购被偷的iphone, 然后进行批量的邮件进行钓鱼, 骗取密码解锁手机.&lt;/p&gt;
&lt;p&gt;于是我告诉妹子, 这种邮件都不要乱点, 不要输入你任何信息.&lt;/p&gt;
&lt;h2&gt;继续&lt;/h2&gt;
&lt;p&gt;陆续几天, 还是有同样的伪造刷机警告发来, 妹子都置之不理. 直到开始受到新的类型的邮件, 大概内容:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你的手机在我们公司, 我们无法解锁, 所以按照我们的收购价800块卖给你. 请看&lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt;, &lt;a href=&quot;#&quot;&gt;店铺地址&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;妹子经过上一波教训, 已经对互联网有一定的畏惧心理, 所以丝毫没动, 转发给我.&lt;/p&gt;
&lt;p&gt;我收到后打开, 明显的, 日然是来历不明的邮箱地址. 而且, 店铺地址的链接也是来历不明的.&lt;/p&gt;
&lt;p&gt;虽然是来历不明的链接, 我还是想点进去看看, 于是, 我进行了点击. 结果是:&lt;/p&gt;
&lt;p&gt;空白页面...&lt;/p&gt;
&lt;p&gt;为什么是空白页面呢, 怎么不是钓鱼网站了? 于是我打开chrome开发者模式, 重新打开链接, 有很多请求, 我意识到, 这可能是xss攻击.&lt;/p&gt;
&lt;p&gt;有一个XXX.qq.com域名的请求, 中间进行了重定向, 然后又发送一个特殊url的请求, 这个url暂不公开, 可以假设为 xsssite.net&lt;/p&gt;
&lt;p&gt;因为妹子的appleid用的是qq邮箱. 所以如果对qq.com域名下的一个网页注入脚本的话, 当用户打开这个网页, 很可能能拿到这个用户的登录信息.&lt;/p&gt;
&lt;p&gt;由于这次我是从转发的邮件打开的链接, 所以泄露的是我的登录信息, 所以并无大碍.(跨站脚本只是获取了你的登录状态, 能够一段时间内伪造登录状态, 而并不是获取了你的密码)&lt;/p&gt;
&lt;p&gt;xsssite.net这个域名的请求包含的很多内容, 且这个网站就是一个xss攻击的平台. 关于这个xss攻击位置, 如何获取登录状态, 传递了哪些信息, 我还尚未去详细查看, 以后分享给大家.&lt;/p&gt;
&lt;p&gt;我很感叹, 这个产业链远比我想象的发达:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小偷 -&amp;gt; 网络诈骗技术者 -&amp;gt; 黑客
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;结果&lt;/h2&gt;
&lt;p&gt;后来, 由于一些事情, 还是在妹子的登录状态打开一个这种连接, 对方登陆了妹子的邮箱, 从而重置了appleid密码, 当然期间有apple的邮件, 但是妹子以为是假的, 直接忽略掉了. 我没有及时得到消息, 还是让对方得逞了.&lt;/p&gt;
&lt;h1&gt;故事之后的反思&lt;/h1&gt;
&lt;p&gt;前面讲了妹子的遭遇, 我又想起近几年几次密码泄露, 信息泄露的事件, 深感互联网安全非常重要, 豺狼虎视眈眈, 但是绝大多数人丝毫没有防范意识. 所以我想了一些关于互联网安全的知识, 提示, 以及应对措施. 给大家普及一下.&lt;/p&gt;
&lt;h4&gt;互联网危险到何种程度&lt;/h4&gt;
&lt;p&gt;请看&lt;a href=&quot;WooYun.org&quot;&gt;乌云网&lt;/a&gt;, 白客们所发现的各种系统漏洞. 触目惊心.&lt;/p&gt;
&lt;p&gt;几年前csdn的数据库泄露事故, 余威犹在. 后续几次京东, 7k7k等网站的大量用户密码泄露都是这次事故的后遗症.&lt;/p&gt;
&lt;p&gt;黑色产业链早已超乎你我的想象. 道高一尺魔高一丈. 你的一切都时时刻刻被攻击者盯着, 不要有侥幸心理.&lt;/p&gt;
&lt;h4&gt;关于密码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;密码与社会工程学&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;社会工程学: 一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段取得自身利益的手法.

举个例子, 最简单的社会工程学案例, 就是根据你的生日来推测你的银行卡密码. 根据人们慵懒的习惯, 尝试`123456`, `asd123`, `abcd` 等方便输入的习惯来推测你的密码. 所以说, 根据你的个人信息, 比如生日, 身份证号, 门牌号, 亲友生日, 名字拼写, 短语拼写等任何对你有意义的字符序列, 都会被认为是你的潜在密码. 依靠计算机的自动化, 计算效率, 可以不停的对大量的用户数据进行尝试破解.

**所以我们应该避免使用和自身信息有关的密码**
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安全并不在你的掌握之中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;使用随机的, 比较复杂的密码, 就可以确保账号安全了么? 很遗憾, 不是的.

因为你的密码不仅仅是你自己要保管, 你所注册的网站, 应用也需要保管. 所以, 你所使用的网站, 应用是否在安全上做足了必要的功夫, 是很重要的.

前几年CSDN数据库泄露, 大量用户资料被盗, 令人震惊的是他们的密码是明文的....

根据用户们懒惰的习惯, 不愿意记很多密码, 于是可以假设用户们都喜欢用同一套用户名密码来登陆所有网站,应用. 一时间, 大量网站,应用被撞库成功.

原则上, 网站是不会保存明文密码的, 他们所保存的是对你的密码进行不可逆加密后的密文, 每次你登陆输入密码, 网站会对输入的密码进行同样的不可逆加密, 然后与保存的密文进行对比来验证正确性. 这样在网站数据库泄露时, 用户密码至少不会以明文显示在盗窃者面前.

同时, 网站也不应该仅仅用md5简单加密. 如今对于简单通用的加密手段, 黑客已经有数量庞大的样本来进行比较, 所以, 简单通用加密的效果已经接近明文了.所以, 加密时加入随机的salt, 是常用的方法.

**避免所有账号都是同一密码. 可以简单分成几级账号密码, 你的关键应用比如qq号, 支付宝, 邮箱等的密码, 一定不要与注册小网站的密码一样.**

**不要轻易进行注册, 尤其对于小网站, 他们的技术相对于薄弱, 安全工作做得不够. 建议小网站都使用第三方认证的方式**
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;二步验证&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;在输入密码后, 需要再进行一次密码验证.

&amp;gt; One Time Password: 一次性密码, 每个密码只在一次, 或者很短的时间内有效. 下次登录或认真, 就会用不同的密码.

这个已经非常常见了, 比如常见的手机验证码, 暴雪战网的安全令牌.

如果你的账号可以开通二步验证, 强烈推荐开通, 虽然每次耽误点时间, 但是可以对你的账号进行非常好的保护.

**Apple ID, Google账号, QQ邮箱(使用qq安全中心) 等都支持二步验证, 建议都去开通一下吧**
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;关于常用邮箱&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;你的安全老巢&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;你的邮箱有多重要? 如果你的邮箱被别人登陆:
1. 首先, 你的个人信息被别人一览无余. 而且, 有的同学还喜欢用邮箱来作为记事本.
2. 可以随时重置你的各种网站, 应用的密码!
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;独立密码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;如果你使用网易, QQ, 新浪等不管是什么邮箱, 要设置独立密码! 如同妹子邮箱被登录的教训. 如果你在网易, QQ, 新浪的账号登录状态被xss攻击获得, 那么攻击者可以直接进入你的邮箱!

这些大网站, 大企业的安全做得很好不用担心? 我承认, 这些大企业的核心业务是没有问题的, 关键在于这些企业家大业大, 设计的方面非常多, 部门也非常多, 甚至分布在不同的地点, 所以不可能所有的地方都能做好安全措施. 妹子这个例子中, 应该是QQ的大粤网中论坛的漏洞, 被进行了xss攻击.

话说回来, 林子大, 什么鸟都有, 你不能保证这些企业当中有黑客的存在. 就像你找人做了个保险箱, 你不能保证这个人是不是留了一把钥匙, 或者在保险箱你不知道地方做了个机关. 尤其对这些企业的非核心业务的技术人员, 并不事都是经过严格考核进来的.
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;不要轻易在浏览器中从邮箱中打开连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;切记, 邮箱中的不确定连接不要轻易就打开, 尤其实在浏览器环境下使用邮箱的时候. 预防xss攻击.

如果打开链接, 发现有异常, 查看请求记录, 如果有疑似xss攻击, 果断退出登录状态, 修改密码. 然后把该链接提交给出现漏斗的网站.(技术工作者)

**如果要在浏览器中打开链接, 请使用&amp;quot;隐身窗口中打开&amp;quot;, 据我所知Chrome, 以及使用Chrome内核的浏览器基本都支持**
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;关于手机号&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;你的安全命门&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;当你的手机丢了, 第一件事, 补卡. 让丢失的卡不能再使用.

当你的手机落入别人手中, 又能正常使用, 那么它可以使用很多应用的二步验证.

作为一些应用的密保手机, 它能够充值你这些应用的密码.

**手机丢了先补卡**
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;如果你对妹子的经历感兴趣, 想获取妹子收到的邮件样本, 请在评论里留下你的邮箱, 说明要获取邮件样本, 我会不定期地查看进行转发.&lt;/p&gt;
&lt;p&gt;当然, 对于产生的一些列问题我特此声明不负任何责任.&lt;/p&gt;
&lt;p&gt;如果你觉得本文对你有帮助和启发, 可以转发给其他人, 以示提醒.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>homebrew安装旧版本软件</title>
      <link>http://blog.yangxiaochen.com/blog/mac/homebrew-install-old-version-soft.html</link>
      <pubDate>星期二, 9 二月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/mac/homebrew-install-old-version-soft.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不需要用brew versions ,这个已经过时了.&lt;/p&gt;
&lt;p&gt;很多有重要版本的软件都已经区分版本的设定formulae了
参见项目地址 https://github.com/Homebrew/homebrew-versions&lt;/p&gt;
&lt;p&gt;比如nodejs   有重要的0.10.*版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yangxiaochen:/usr/local$ brew search node
leafnode node node010 node04 node06 node08 nodebrew nodenv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;node010就是&lt;/p&gt;
&lt;p&gt;同理php也是这样分php56 php55 php54 ….&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>python入门</title>
      <link>http://blog.yangxiaochen.com/blog/develop/python-starter.html</link>
      <pubDate>星期二, 9 二月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/develop/python-starter.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;本文不讲python语法, 因为语法手册到处都有, 而且也不难, 本文旨在介绍python的生态环境和开发环境搭建.&lt;/p&gt;
&lt;h2&gt;生态&lt;/h2&gt;
&lt;h3&gt;包管理工具 pip&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;python 3.*版本自带&lt;/li&gt;
&lt;li&gt;python 2.*须另外安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pip 文档地址&lt;a href=&quot;https://pip.pypa.io/en/latest/&quot;&gt;pip文档&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;虚拟环境 Virtualenv&lt;/h3&gt;
&lt;p&gt;python安装类库为全局安装, 在一台机器上一个用户安装一个类库, 对该机器上所有用户和项目有效. 所以为了解决这个问题, 引入了虚拟环境, 使依赖类库管理编程项目范围.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;python 3.*版本自带&lt;/li&gt;
&lt;li&gt;python 2.*须另外安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Virtualenv 文档地址&lt;a href=&quot;https://virtualenv.pypa.io/en/latest/&quot;&gt;Virtualenv文档&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>rabbitmq管理使用实践</title>
      <link>http://blog.yangxiaochen.com/blog/develop/rabbitmq-in-action.html</link>
      <pubDate>星期一, 8 二月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/develop/rabbitmq-in-action.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;!-- more --&gt;
&lt;h1&gt;MQ数据源&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;datasource -&amp;gt; topic exchange&lt;/code&gt;, 数据源已固定格式发入exchange, exchange类型为topic,既可以使用路由route_key, 又可以进行通配. 不要将生产者, 消费者用在同一队列上, 这样耦合度高, 消息无法复用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据源只关心输入exchange, 对后续消费者无需关心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新加,修改数据源需要备案记录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者一般情况下使用临时队列, 必要情况下使用持久队列. 队列从数据源的exchange中订阅数据.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中不要生成持久的exchange, queue. 而是在管理界面生成. 防止程序改动造成的废弃的exchange, queue仍然存在在rabbitmq中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名统一.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; exchangeName: datasource:[sth.sth]
 queueName: [消费者程序名称]:[exchangeName].[subject]
 route_key: [exchangeName].[subject]

 例:
 exchangeName: datasource:dispatch.event
 queueName: autoDispatch:dispatch.event.orderCreate
 route_key: dispatch.event.orderCreate
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;poi&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;exchangeName: datasource:poi
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;业务事件流&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;exchangeName: datasource:dispatch.event
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;日志流&lt;/h3&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;h1&gt;rabbitmq 规范&lt;/h1&gt;
&lt;h2&gt;使用规范&lt;/h2&gt;
&lt;h3&gt;0. 使用原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数据源已固定格式发入exchange, exchange类型为topic.数据源只关心输入exchange.&lt;/li&gt;
&lt;li&gt;修改数据源, 持久队列, 持久内部exchange需要备案记录.&lt;/li&gt;
&lt;li&gt;消费者一般非必要情况下使用临时队列. 队列从数据源的exchange中订阅数据.&lt;/li&gt;
&lt;li&gt;程序中不要生成持久的exchange, queue. 而是在管理界面生成.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1. datasourceExchanges&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; datasource:[datasourceName]

 例:
 datasource:poi
 datasource:dispatch.event
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git@gitlab.supaide.cn:sys/rabbitmq.git
 datasources.txt

 备案说明详见文件内部格式.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2. durable queues, exchanges&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; queueName
 [appName]:[routingKey]

 exchangeName
 x:[appName]:[routingKey]

 例:
 autoDispatch:dispatch.event.orderCreate
 x:autoDispatch:dispatch.event.*
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git@gitlab.supaide.cn:sys/rabbitmq.git
 durableQueues.txt

 备案说明详见文件内部格式.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3. temp queues, exchagnes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gen.[appName]:[routingKey]

 or

 默认随机名称
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 无需备案
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;

	</description>
    </item>
    <item>
      <title>css 定位指南</title>
      <link>http://blog.yangxiaochen.com/blog/frontend/css-position.html</link>
      <pubDate>星期二, 8 十一月 2011 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/frontend/css-position.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;前置知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;了解html各个标签&lt;/li&gt;
&lt;li&gt;对css各种属性有一些了解&lt;/li&gt;
&lt;li&gt;理解盒子模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;对于网页制作的新手来说, 了解了html各种标签的含义, 并不能够制作出像网上那些绚丽的网页.
一个网页的制作过程, 要经过一下几个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计&lt;/li&gt;
&lt;li&gt;布局分析&lt;/li&gt;
&lt;li&gt;编写html, 并用css布局&lt;/li&gt;
&lt;li&gt;css来进行各个布局区块内部的样式编写&lt;/li&gt;
&lt;li&gt;js来编写动态效果和其他功能脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们这里研究的是第三部分: 当我们确定了布局, 如何用html和css把布局描述出来&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;html编写&lt;/p&gt;
&lt;p&gt;html是用来表达文档结构的,当看到一个h1标签, 不应该去想这一标签让文字放大加粗, 而应该想这个标签引用的文字, 是一个一级标题, 这才是html的初衷. html中不应该出现描述样式的属性如&lt;code&gt;width&lt;/code&gt;, &lt;code&gt;sytle&lt;/code&gt;等.&lt;/p&gt;
&lt;p&gt;html不应该去思考样式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档流&lt;/p&gt;
&lt;p&gt;怎么定位? 很多人直接就开始讲定位的属性和方法. 其实, 要真正理解定位, 就要先了解文档流.&lt;/p&gt;
&lt;p&gt;什么是文档流? 写出来的html文档的顺序, 就是文档流的顺序. 当不加任何修饰的时候, 页面上显示出来的时候, 和你html代码是很相像. 也就是说, 所写的html文档的各个元素, 是按这个默认顺序排列下来的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位
有了这个基础,再来看定位:定位有两种方式.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;float定位&lt;/p&gt;
&lt;p&gt;float有两个值:&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;. 分别表示向左向右浮动. 一旦一个元素采用了float进行定位, 那么这个元素将脱离文档流. 意思是这个元素虽然在页面上还看得到, 但是已经不据占位置了, 后面的元素会补上来.&lt;/p&gt;
&lt;p&gt;那么它会到哪呢? 飘走了… 一个较为明确的说法是: 因为任何一个元素可以成为一个盒子模型, 那么这个元素有个边框, 浮动的框可以根据float的值是&lt;code&gt;left&lt;/code&gt;还是&lt;code&gt;right&lt;/code&gt;进行向左或向右移动, 直到它的外边缘碰到父元素的边框或另一个同级元素的边框为止.&lt;/p&gt;
&lt;p&gt;float的块级元素将不占一正行, 宽度为内容实际宽度.&lt;/p&gt;
&lt;p&gt;在这个元素后面的文档流部分会顶上来, 取代这个元素的位置. 但是后面那个元素里的内容, 比如说文字, 会围绕在上面那个浮动元素周围. 这个效果不是很好表达,大家可以自己做个试验. 定义两个div, 里面都写上文字, 注意第二个div里的文字要比第一个多(这样才能环绕), 让后给第一个加CSS属性:&lt;code&gt;float:left&lt;/code&gt;. 然后就看到效果了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;position定位&lt;/p&gt;
&lt;p&gt;position有四个值:&lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;fix&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先说static,这个是默认值,每个元素如果没有定义position属性,就等于是这个值.所以,不解释了,可以说就是没有定位方式.&lt;/p&gt;
&lt;p&gt;关键是其他的三种.选择其中任何一个后,就可以按自己需求布局了.这时候你可以用CSS中的四个属性:&lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;. 比如&lt;code&gt;top:100px&lt;/code&gt;, 表示相对于”相对元素”(稍后解释这个相对元素)的顶部有&lt;code&gt;100px&lt;/code&gt;的距离.其他以此类推.&lt;/p&gt;
&lt;p&gt;相对元素是什么? &lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;fix&lt;/code&gt;这三个值决定了这个相对元素:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;relative&lt;/p&gt;
&lt;p&gt;元素会相对于自身原来在文档流的位置进行偏移. 这时定义&lt;code&gt;top:100px&lt;/code&gt;就表示相对它本来应该在的位置向下偏移了&lt;code&gt;100px&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;absolute&lt;/p&gt;
&lt;p&gt;元素框从文档流完全删除, 并相对于其包含块定位.&lt;/p&gt;
&lt;p&gt;包含块定义:&lt;/p&gt;
&lt;p&gt;这个包含块并不一定是直接父元素, 一个元素可能被包在好几层块之内. 距离最近的,postion属性为absolute relative fixed 三者之一的祖先元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fixed&lt;/p&gt;
&lt;p&gt;元素框的表现类似于将 position 设置为 &lt;code&gt;absolute&lt;/code&gt;，不过其包含块是视窗本身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;练习与参考&lt;/h2&gt;
&lt;p&gt;以上是定位的理论, css的学习是一个不断熟练的过程, 写的时候可以参照成熟网站的类似布局, 通过chrome开发者模式来研究别人的页面写法很有裨益.&lt;/p&gt;
&lt;p&gt;另外[CSS禅意花园]这本书值得一看, 虽然比较老, 但是里面的一些基础知识, 基本css写法是值得学习的.&lt;/p&gt;

	</description>
    </item>

  </channel> 
</rss>
