= 项目接口设计实践
杨晓辰
2019-07-25
:toc: left
:toclevels: 4
:icons: font
:sectnums:
:jbake-type: post
:jbake-tags: code_and_think, java, api
:jbake-status: published

== 前言

项目不同, 项目提供的接口功能也不同, 能否有一套比较通用切良好的规则, 来指导我们对项目接口的宏观设计和细节设计? 

本文是我在项目中设计 api 接口的一些实践经验.

== 接口
=== 宏观战略
==== 接口组织结构

一个项目中, 接口组织结构应该是良好干净的. 接口不是想写哪里写哪里, 接口需要有功能分类, 业务分类, 协议分类, 然后分门别类的组织在不同的文件夹里.

按照功能作用分::
* 系统间服务接口
* 前端接口  

按照业务分::
* 业务模块 A
* 业务模块 B

按照协议分::
* dubbo
* http

很多人多多少少想过这些分类, 但很少想过要把接口按照这些组织好. 我给出一个接口的组织目录

[source,java]
----
application 
+-- api                         // 面向服务的接口
|   +-- dubbo                   // dubbo 协议的接口
|   |   +-- order               // 按照业务化分, order 模块的接口
|   |   +-- product
|   |   \-- module C
|   \-- http                    // http 协议的接口
+-- controller                  // 面向前端的接口
|   +-- web                     // ajax 请求接口
|   |   +-- order               // 按照业务化分
|   |   \-- product 
|   +-- page                    // 页面请求接口
|   +-- manage                  // 管理用的 ajax 和 页面接口.
|       +-- web
|       \-- page
\-- callback                    // 接收回调的接口
----

* 首先按照面向服务, 面向前端进行化分.

** 验证方式不同. 面向前端的接口通常要认证登录状态; 面向服务的接口通常是接入验证.
** 使用者不同. 前端接口调用者是用户, 请求的数据通常更贴近展示, 面向展示设计接口, 当发生异常时, 需要返回一些用户可读的信息; 服务接口使用者是系统代码, 请求的数据更贴近领域模型, 根据自身领域来暴露服务, 发生异常时, 需要返回明确的状态码, 来供调用方程序判断.

* 在面向服务的接口中, 提供了不同协议的接口. 不同协议的接口中, 又按照不同的模块化分.
* 在面向前端的接口中, 分为 `web` 和 `page` 两种, 分别应对 ajax 请求和页面请求.
* 在面向前端的接口中, `manage` 包里为管理后台的接口. 因为管理后台通常跟前台的请求要求的身份权限不同.
* 独立出 `callback` 类型的接口, 这种接口往往按照回调发起方的接口规范来.

以上, 我们通过接口的受众和类型, 制定了一套接口的组织形式. 

目的是保持清晰, 避免混用. 因为我们经常会在接口层做一些通用的操作, 比如日志, 性能打点, 认证等, 对于不同的功能和作用的接口是不同的, 做划分之后, 我们可以分别处理.

上面的目录划分的真实代码示例, 可以在 https://github.com/yxc023/blueprint/tree/master/blueprint-application/src/main/java/com/yangxiaochen/blueprint[blueprint project] 找到.

=== 细节战术

==== 通用
. 读接口无副作用, 不要返回业务异常或错误码
获取信息的时候, 有就是有, 没有就是没有. 比如, 当调用 `getOrder(orderId)` 接口时, 没有数据就返回 `null`, 而不要返回一个错误叫做 `订单不存在`.

. 面向服务的写接口声明会发生的各种异常和错误码

. 面向服务的接口设计应该以自身业务另约需要暴露的功能为出发点, 而不是尊奉需求方的要求.

. 设计完之后, 要站在使用者的角度试用自己的接口, 看是否有问题.

. 接口给出粗粒度的数据

==== 面向服务
===== http
. 服务接口 path 为 `/api/**`
. 通过 header 传递额外信息. 比如 appId, timestamp, 签名信息等. 
. 写接口使用 `POST`, 接收参数类型为 `application/json`.
. 对 `POST` 的写接口进行验签时, 由于 content 是 json 类型, 格式层次复杂, 不能把每个字段拿出来加入到签名中做校验, 所以把 content 的内容做哈希算法签名, 来做为一个校验字段, 而不用使用 content 里单独的字段来做.
. 使用统一的 `ApiResult` 对象封装结果返回. `ApiResult` 包含 `code`, `message`, `tip`, `data` 等字段.
. 写接口的返回值中的 `code` 应为字符串类型, 用于更有表达力的表明各种异常状态.
. response status code 使用. 参考 https://tools.ietf.org/html/rfc7231#section-6.1[RFC 7231]
** 正常和业务异常 - 200
** 参数校验错误 - 400
** 验签未通过 - 401
** 验签通过但是无权限使用接口 - 403
** 意料外异常 - 500
** 限流, 熔断, 拒绝服务 - 503

===== dubbo
. dubbo 接口的设计理念: 尽量使 rpc 调用看上去跟调用本地方法一样.
+
结果无需再做封装, 成功就是成功了, 失败通过异常类传递.

. 读接口直接返回数据, 无需额外封装. 读接口不抛业务异常, 有异常就认为 bug.
+
TIP: link:https://github.com/yxc023/blueprint/blob/master/blueprint-application/src/main/java/com/yangxiaochen/blueprint/api/dubbo/order/OrderFacade.java[OrderFacade#getByOrderId]

. 写接口返回数据无需额外封装. 业务异常信息通过 `Exception` 抛出, 并包含异常 `code`.



. dubbo 接口实现中, 要做异常全局处理, 转化为 `ApiException`. 并将 `ApiException` 放到发布的 api 包中. 否则无法在 dubbo 客户端对异常反序列化.
. dubbo 接口不应返回枚举类型以及包含枚举类型的对象. 应该转成字符串或数字常量返回. 避免客户端因为服务端枚举类变化导致反序列化的失败.
. dubbo 发布的 api 包中, 应包含接口用到的**常量**, **数据对象**, **异常 code 常量**.
. dubbo 发布的 api 包中, 应该配套 source 包. 源码中应该有足够的注释.
. dubbo 的认证信息可以包含在 `attachment` 里.

==== 面向前端
. 前端接口 path 为 `/web/**`.
. 前端接口的设计理念: 为展示而生, 能够为让前端直接做显示而不用做一些逻辑判断. 但是不能完全脱离业务模型.
. 使用统一的 `Result` 对象封装结果返回. `Result` 包含 `code`, `message`, `tip`, `data` 等字段.
. 异常要统一包装成数据返回, 需要返回人类可读的 tip. 绝大多数异常情况接口不需要返回特定错误码.
. response status code 使用. 参考 https://tools.ietf.org/html/rfc7231#section-6.1[RFC 7231]
** 正常和业务异常 - 200  
** 参数校验错误 - 200 - tip: 参数错误: 
** 验签未通过 - 401 - 且返回 header 中包含重定向 location, 供前端同学跳转登录.
** 验签通过但是无权限使用接口 - 403 - tip: 你没有相关权限.
** 意料外异常 - 200 - tip: 发生内部错误, 工程师已经收到正在修复. 有问题请联系 XXX.
** 限流, 熔断, 拒绝服务 - 200 - tip: 当前系统繁忙, 请稍候再试

==== callback
. callback 接口 path 为 `/callback/**`
. callback 接口尊奉回调发起方的接口格式要求.

== 文档
